
loadstring(game:HttpGet('https://raw.githubusercontent.com/fathater21211/Aladia/refs/heads/main/bypass?token=GHSAT0AAAAAADCNLTVA3DCWW3LEFFJV5QOU2BRFREA'))()



local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Quantum|Aladia PVP",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Rayfield Interface Suite",
   LoadingSubtitle = "by Sirius",
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Aladia"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local ATab = Window:CreateTab("Aim", "crosshair") -- Title, Image
local ETab = Window:CreateTab("Visuals", "scan-eye" ) -- Title, Image
local MTab = Window:CreateTab("Misc", "notepad-text") -- Title, Image
local STab = Window:CreateTab("Themes", "Cog" ) -- Title, Image
local CTab = Window:CreateTab("Credits", "notepad-text") -- Title, Image

Window.ModifyTheme('Ocean')-- getvisual.cc






getgenv().select_options = nil 
--Theme Name - ThemeIdentifier

--Default - Default
--Amber Glow - AmberGlow
--Amethyst - Amethyst
--Bloom - Bloom
--Dark Blue - DarkBlue
--Green - Green
--Light - Light
--Ocean - Ocean
--Serenity - Serenity

print('Bypassing Corescript')
Rayfield:Notify({
    Title = "Bypass",
    Content = "Bypassed CoreScript",
    Duration = 6.5,
    Image = 4483362458,
 })
task.wait(0.2)
Rayfield:Notify({
    Title = "Bypass",
    Content = "Bypassed Anti-Cheat",
    Duration = 6.5,
    Image = 4483362458,
 })
print('Adonis Bypassed')
task.wait(0.2)
print('Loading')

task.wait(2)
Rayfield:Notify({
    Title = "Bypass",
    Content = "Bypassed Adonis",
    Duration = 6.5,
    Image = 4483362458,
 })

 Rayfield:Notify({
    Title = "Loader",
    Content = "Loading Script!",
    Duration = 6.5,
    Image = 4483362458,
 })

 task.wait(3)

Rayfield:Notify({
    Title = "Loaded in %",
    Content = "Loaded Quantum in 4ms!",
    Duration = 6.5,
    Image = 4483362458,
 })


 
Rayfield:Notify({
    Title = "AC",
    Content = "AC Succesfully bypassed!",
    Duration = 6.5,
    Image = 4483362458,
 })

 local Toggle = ATab:CreateToggle({
    Name = "Aimbot",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
		--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Camera = game:GetService("Workspace").CurrentCamera

--// Variables

local LocalPlayer = Players.LocalPlayer
local Title = "JDDEV"
local FileNames = {"Aimbot", "Configuration.json", "Drawing.json"}
local Typing, Running, Animation, RequiredDistance, ServiceConnections = false, false, nil, 2000, {}

--// Support Functions

local mousemoverel = mousemoverel or (Input and Input.MouseMove)
local queueonteleport = queue_on_teleport or syn.queue_on_teleport

--// Script Settings

Environment.Settings = {
	SendNotifications = true,
	SaveSettings = true, -- Re-execute upon changing
	ReloadOnTeleport = true,
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = false, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = "255,192,203",
	LockedColor = "252,15,192",
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")
Environment.Locked = nil

--// Core Functions

local function Encode(Table)
	if Table and type(Table) == "table" then
		local EncodedTable = HttpService:JSONEncode(Table)

		return EncodedTable
	end
end

local function Decode(String)
	if String and type(String) == "string" then
		local DecodedTable = HttpService:JSONDecode(String)

		return DecodedTable
	end
end

local function GetColor(Color)
	local R = tonumber(string.match(Color, "([%d]+)[%s]*,[%s]*[%d]+[%s]*,[%s]*[%d]+"))
	local G = tonumber(string.match(Color, "[%d]+[%s]*,[%s]*([%d]+)[%s]*,[%s]*[%d]+"))
	local B = tonumber(string.match(Color, "[%d]+[%s]*,[%s]*[%d]+[%s]*,[%s]*([%d]+)"))

	return Color3.fromRGB(R, G, B)
end

local function SendNotification(TitleArg, DescriptionArg, DurationArg)
	if Environment.Settings.SendNotifications then
		StarterGui:SetCore("SendNotification", {
			Title = TitleArg,
			Text = DescriptionArg,
			Duration = DurationArg
		})
	end
end

--// Functions

local function SaveSettings()
	if Environment.Settings.SaveSettings then
		if isfile(Title.."/"..FileNames[1].."/"..FileNames[2]) then
			writefile(Title.."/"..FileNames[1].."/"..FileNames[2], Encode(Environment.Settings))
		end

		if isfile(Title.."/"..FileNames[1].."/"..FileNames[3]) then
			writefile(Title.."/"..FileNames[1].."/"..FileNames[3], Encode(Environment.FOVSettings))
		end
	end
end

local function GetClosestPlayer()
	if not Environment.Locked then
		if Environment.FOVSettings.Enabled then
			RequiredDistance = Environment.FOVSettings.Amount
		else
			RequiredDistance = 2000
		end

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		Environment.Locked = nil
		Animation:Cancel()
		Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Create, Save & Load Settings

if Environment.Settings.SaveSettings then
	if not isfolder(Title) then
		makefolder(Title)
	end

	if not isfolder(Title.."/"..FileNames[1]) then
		makefolder(Title.."/"..FileNames[1])
	end

	if not isfile(Title.."/"..FileNames[1].."/"..FileNames[2]) then
		writefile(Title.."/"..FileNames[1].."/"..FileNames[2], Encode(Environment.Settings))
	else
		Environment.Settings = Decode(readfile(Title.."/"..FileNames[1].."/"..FileNames[2]))
	end

	if not isfile(Title.."/"..FileNames[1].."/"..FileNames[3]) then
		writefile(Title.."/"..FileNames[1].."/"..FileNames[3], Encode(Environment.FOVSettings))
	else
		Environment.Visuals = Decode(readfile(Title.."/"..FileNames[1].."/"..FileNames[3]))
	end

	coroutine.wrap(function()
		while wait(10) and Environment.Settings.SaveSettings do
			SaveSettings()
		end
	end)()
else
	if isfolder(Title) then
		delfolder(Title)
	end
end

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Settings.ThirdPerson then
				Environment.Settings.ThirdPersonSensitivity = math.clamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

				local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
				mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
			else
				if Environment.Settings.Sensitivity > 0 then
					Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
					Animation:Play()
				else
					Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
				end
			end

			Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.LockedColor)
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							Environment.Locked = nil
							Animation:Cancel()
							Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							Environment.Locked = nil
							Animation:Cancel()
							Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if not Environment.Settings.Toggle then
						Running = false
						Environment.Locked = nil
						Animation:Cancel()
						Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if not Environment.Settings.Toggle then
						Running = false
						Environment.Locked = nil
						Animation:Cancel()
						Environment.FOVCircle.Color = GetColor(Environment.FOVSettings.Color)
					end
				end
			end)
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	SaveSettings()

	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
end

function Environment.Functions:Restart()
	SaveSettings()

	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		SendNotifications = true,
		SaveSettings = true, -- Re-execute upon changing
		ReloadOnTeleport = true,
		Enabled = true,
		TeamCheck = true,
		AliveCheck = true,
		WallCheck = true,
		Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false,
		ThirdPersonSensitivity = 3,
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "Head" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = "255, 193, 202",
		LockedColor = "255, 70, 70",
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Support Check

if not Drawing or not getgenv then
	SendNotification(Title, "Your exploit does not support this script", 3); return
end

--// Reload On Teleport

if Environment.Settings.ReloadOnTeleport then
	if queueonteleport then
		queueonteleport(game:HttpGet("https://raw.githubusercontent.com/Exunys/Aimbot-V2/main/Resources/Scripts/Main.lua"))
	else
		SendNotification(Title, "Your exploit does not support \"syn.queue_on_teleport()\"")
	end
end

--// Load

Load()
    end,
 })

 local Divider = ATab:CreateDivider()
 

 local Slider = ATab:CreateSlider({
    Name = "Fov Amount",
    Range = {0, 200},
    Increment = 10,
    Suffix = "FOV",
    CurrentValue = 10,
    Flag = "fov circle size", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
		if getgenv().Aimbot and getgenv().Aimbot.FOVSettings then
            getgenv().Aimbot.FOVSettings.Amount = Value

        end    
    end,
 })

 

--Default - Default
--Amber Glow - AmberGlow
--Amethyst - Amethyst
--Bloom - Bloom
--Dark Blue - DarkBlue
--Green - Green
--Light - Light
--Ocean - Ocean
--Serenity - Serenity

local Button = STab:CreateButton({
	Name = "Default Theme",
	Callback = function()
		Window.ModifyTheme('Default')-- getvisual.cc
	end,
 })

 local Button = STab:CreateButton({
	Name = "AmberGlow Theme",
	Callback = function()
		Window.ModifyTheme('AmberGlow')-- getvisual.cc
	end,
 })

 local Button = STab:CreateButton({
	Name = "Amethyst Theme",
	Callback = function()
		Window.ModifyTheme('Amethyst')-- getvisual.cc
	end,
 })

 local Button = STab:CreateButton({
	Name = "Bloom Theme",
	Callback = function()
		Window.ModifyTheme('Bloom')-- getvisual.cc
	end,
 })

 local Button = STab:CreateButton({
	Name = "Dark Blue Theme",
	Callback = function()
		Window.ModifyTheme('DarkBlue')-- getvisual.cc
	end,
 })

 local Button = STab:CreateButton({
	Name = "Green Theme",
	Callback = function()
		Window.ModifyTheme('Green')-- getvisual.cc
	end,
 })

 local Button = STab:CreateButton({
	Name = "Light Theme",
	Callback = function()
		Window.ModifyTheme('Light')-- getvisual.cc
	end,
 })

 local Button = STab:CreateButton({
	Name = "Ocean Theme",
	Callback = function()
		Window.ModifyTheme('Ocean')-- getvisual.cc
	end,
 })

 local Button = STab:CreateButton({
	Name = "Serenity Theme",
	Callback = function()
		Window.ModifyTheme('Serenity')-- getvisual.cc
	end,
 })


 local Label = CTab:CreateLabel("Created By X64.External", "square-pen", Color3.fromRGB(255, 255, 255), false) -- Title, Icon, Color, IgnoreTheme
 local Label = CTab:CreateLabel("Quantum Script Studios (External, Plasma)", 4483362458, Color3.fromRGB(255, 255, 255), false) -- Title, Icon, Color, IgnoreTheme


 
 local Slider = MTab:CreateSlider({
    Name = "WalkSpeed",
    Range = {0, 200}, -- Min: 0, Max: 200
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16, -- Default WalkSpeed
    Flag = "Walkspeed", 
    Callback = function(Value)
        -- Ensure the Value is a number and set the WalkSpeed
        _G.WS = Value

        -- Get the player's humanoid
        local Humanoid = game:GetService("Players").LocalPlayer.Character.Humanoid

        -- Ensure the humanoid is valid and connected
        if Humanoid then
            -- Update WalkSpeed immediately
            Humanoid.WalkSpeed = _G.WS

            -- Listen for any changes to WalkSpeed and maintain the value
            Humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
                Humanoid.WalkSpeed = _G.WS
            end)
        end
    end,
})



local Toggle = ETab:CreateToggle({
	Name = "Box Esp",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
		local LocalPlayer = Players.LocalPlayer
		local Camera = workspace.CurrentCamera
		
		-- ESP Configuration for Box
		local ESP_Box = {
			Enabled = true,
			BoxThickness = 2,
			BoxTransparency = 0.5,
			MaxDistance = 5000,  -- Max Distance to show ESP
		}
		
		-- Storage for Box ESP objects
		local ESP_BoxObjects = {}
		
		-- Function to create Box ESP for a player
		local function CreateBoxESPForPlayer(player)
			if player == LocalPlayer then return end
		
			local espObject = {}
		
			-- Box outline for player
			espObject.Box = Drawing.new("Square")
			espObject.Box.Visible = false
			espObject.Box.Thickness = ESP_Box.BoxThickness
			espObject.Box.Transparency = ESP_Box.BoxTransparency
			espObject.Box.Filled = false
		
			ESP_BoxObjects[player] = espObject
		
			-- Clear ESP when player leaves
			player.AncestryChanged:Connect(function()
				if not player:IsDescendantOf(game) then
					if ESP_BoxObjects[player] then
						ESP_BoxObjects[player].Box:Remove()
						ESP_BoxObjects[player] = nil
					end
				end
			end)
		end
		
		-- Create Box ESP for all existing players
		for _, player in pairs(Players:GetPlayers()) do
			if player ~= LocalPlayer then
				CreateBoxESPForPlayer(player)
			end
		end
		
		-- Create Box ESP for new players who join
		Players.PlayerAdded:Connect(CreateBoxESPForPlayer)
		
		-- Clear Box ESP for players who leave
		Players.PlayerRemoving:Connect(function(player)
			if ESP_BoxObjects[player] then
				ESP_BoxObjects[player].Box:Remove()
				ESP_BoxObjects[player] = nil
			end
		end)
		
		-- Update Box ESP on each frame
		RunService.RenderStepped:Connect(function()
			if not ESP_Box.Enabled then
				-- Hide all Box ESP elements if disabled
				for _, espObject in pairs(ESP_BoxObjects) do
					espObject.Box.Visible = false
				end
				return
			end
		
			for player, espObject in pairs(ESP_BoxObjects) do
				-- Get character and make sure it's valid
				local character = player.Character
				if not character or not character:FindFirstChild("HumanoidRootPart") then
					espObject.Box.Visible = false
					continue
				end
		
				local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
				local vector, onScreen = Camera:WorldToViewportPoint(humanoidRootPart.Position)
				local distance = (humanoidRootPart.Position - Camera.CFrame.Position).Magnitude
		
				if onScreen and distance <= ESP_Box.MaxDistance then
					-- Get player size for box ESP (using character bounds)
					local topPosition = humanoidRootPart.Position + Vector3.new(0, 3, 0)
					local bottomPosition = humanoidRootPart.Position - Vector3.new(0, 3, 0)
					local topVector = Camera:WorldToViewportPoint(topPosition)
					local bottomVector = Camera:WorldToViewportPoint(bottomPosition)
		
					local height = math.abs(topVector.Y - bottomVector.Y)
					local width = height * 0.6
					local boxPosition = Vector2.new(vector.X - width / 2, vector.Y - height / 2)
					local boxSize = Vector2.new(width, height)
		
					-- Update box ESP
					espObject.Box.Position = boxPosition
					espObject.Box.Size = boxSize
					espObject.Box.Color = player.TeamColor.Color
					espObject.Box.Visible = true
				else
					espObject.Box.Visible = false
				end
			end
		end)

	end,
 })


 local Toggle = ETab:CreateToggle({
	Name = "Health Bar Esp",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
	local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ESP Configuration for Health Bar
local ESP_HealthBar = {
    Enabled = true,
    ShowHealthBar = true,
    HealthBarThickness = 2,
    HealthBarWidth = 50,
    HealthBarHeight = 5,
    MaxDistance = 5000,  -- Max Distance to show ESP
}

-- Storage for Health Bar ESP objects
local ESP_HealthBarObjects = {}

-- Function to create Health Bar ESP for a player
local function CreateHealthBarESPForPlayer(player)
    if player == LocalPlayer then return end

    local espObject = {}

    -- Health bar background (gray)
    espObject.HealthBG = Drawing.new("Square")
    espObject.HealthBG.Visible = false
    espObject.HealthBG.Thickness = ESP_HealthBar.HealthBarThickness
    espObject.HealthBG.Filled = true
    espObject.HealthBG.Color = Color3.fromRGB(100, 100, 100)
    espObject.HealthBG.Transparency = 0.7

    -- Health bar fill (green to red depending on health)
    espObject.HealthBar = Drawing.new("Square")
    espObject.HealthBar.Visible = false
    espObject.HealthBar.Thickness = ESP_HealthBar.HealthBarThickness
    espObject.HealthBar.Filled = true
    espObject.HealthBar.Transparency = 0.7

    ESP_HealthBarObjects[player] = espObject

    -- Clear ESP when player leaves
    player.AncestryChanged:Connect(function()
        if not player:IsDescendantOf(game) then
            if ESP_HealthBarObjects[player] then
                ESP_HealthBarObjects[player].HealthBG:Remove()
                ESP_HealthBarObjects[player].HealthBar:Remove()
                ESP_HealthBarObjects[player] = nil
            end
        end
    end)
end

-- Create Health Bar ESP for all existing players
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        CreateHealthBarESPForPlayer(player)
    end
end

-- Create Health Bar ESP for new players who join
Players.PlayerAdded:Connect(CreateHealthBarESPForPlayer)

-- Clear Health Bar ESP for players who leave
Players.PlayerRemoving:Connect(function(player)
    if ESP_HealthBarObjects[player] then
        ESP_HealthBarObjects[player].HealthBG:Remove()
        ESP_HealthBarObjects[player].HealthBar:Remove()
        ESP_HealthBarObjects[player] = nil
    end
end)

-- Function to get health color based on percentage
local function GetHealthColor(health, maxHealth)
    local healthPercent = health / maxHealth
    local r = math.clamp(2 * (1 - healthPercent), 0, 1)
    local g = math.clamp(2 * healthPercent, 0, 1)
    return Color3.new(r, g, 0)
end

-- Update Health Bar ESP on each frame
RunService.RenderStepped:Connect(function()
    if not ESP_HealthBar.Enabled then
        -- Hide all Health Bar ESP elements if disabled
        for _, espObject in pairs(ESP_HealthBarObjects) do
            espObject.HealthBG.Visible = false
            espObject.HealthBar.Visible = false
        end
        return
    end

    for player, espObject in pairs(ESP_HealthBarObjects) do
        -- Get character and make sure it's valid
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then
            espObject.HealthBG.Visible = false
            espObject.HealthBar.Visible = false
            continue
        end

        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")
        local health = humanoid.Health
        local maxHealth = humanoid.MaxHealth

        -- Check if character is on screen and within max distance
        local vector, onScreen = Camera:WorldToViewportPoint(humanoidRootPart.Position)
        local distance = (humanoidRootPart.Position - Camera.CFrame.Position).Magnitude

        if onScreen and distance <= ESP_HealthBar.MaxDistance then
            -- Update health bar background
            espObject.HealthBG.Position = Vector2.new(vector.X - ESP_HealthBar.HealthBarWidth / 2, vector.Y - 10)
            espObject.HealthBG.Size = Vector2.new(ESP_HealthBar.HealthBarWidth, ESP_HealthBar.HealthBarHeight)
            espObject.HealthBG.Visible = ESP_HealthBar.ShowHealthBar

            -- Update health bar fill
            local healthPercent = health / maxHealth
            espObject.HealthBar.Position = Vector2.new(vector.X - ESP_HealthBar.HealthBarWidth / 2, vector.Y - 10)
            espObject.HealthBar.Size = Vector2.new(ESP_HealthBar.HealthBarWidth * healthPercent, ESP_HealthBar.HealthBarHeight)
            espObject.HealthBar.Color = GetHealthColor(health, maxHealth)
            espObject.HealthBar.Visible = ESP_HealthBar.ShowHealthBar
        else
            espObject.HealthBG.Visible = false
            espObject.HealthBar.Visible = false
        end
    end
end)
	end,
 })

 local Toggle = ATab:CreateToggle({
	Name = "Wall Check",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
	-- The function that takes place when the toggle is pressed
	-- The variable (Value) is a boolean on whether the toggle is true or false
	end,
 })

 local Toggle = ATab:CreateToggle({
	Name = "Alive Check",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
	-- The function that takes place when the toggle is pressed
	-- The variable (Value) is a boolean on whether the toggle is true or false
	end,
 })

 local Toggle = ATab:CreateToggle({
	Name = "Team Check",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
	-- The function that takes place when the toggle is pressed
	-- The variable (Value) is a boolean on whether the toggle is true or false
	end,
 })

 local Divider = ATab:CreateDivider()
 
 local Toggle = ATab:CreateToggle({
	Name = "Big Head",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
	
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local head = character:FindFirstChild("Head")

local function resizeHead(part)
    if part then
        part.Size = Vector3.new(5, 5, 5)
        part.Transparency = 0.5
    end
end

local function stopResizing(part)
    if part then
        return part.Size == Vector3.new(5, 5, 5)
    end
    return false
end

local function shouldResizeLocalPlayer()
    return head and not stopResizing(head)
end

while true do
    -- Resize the player's head if it's not already resized
    if shouldResizeLocalPlayer() then
        resizeHead(head)
    end

    -- Resize heads of other players
    for _, v in ipairs(game.Players:GetPlayers()) do
        if v ~= player and v.Character then
            local otherHead = v.Character:FindFirstChild("Head")
            if not stopResizing(otherHead) then
                resizeHead(otherHead)
            end
        end
    end

    -- Resize heads of all parts and models in the workspace
    for _, h in ipairs(game.Workspace:GetDescendants()) do
        if h:IsA("Model") or h:IsA("Part") then
            local headU = h:FindFirstChild("Head")
            if not stopResizing(headU) then
                resizeHead(headU)
            end
        end
    end

    wait(3) -- a small delay to prevent excessive loop iteration dont put too less or else is lag unless you have good device of wifi
end
	end,
 })

 local Dropdown = ETab:CreateDropdown({
    Name = "Skybox Changer",
    Options = {"Asthetic Sky"},
    CurrentOption = {"Option 1"},
    MultipleOptions = false,
    Flag = "Dropdown1", -- A flag is the identifier for the configuration file
    Callback = function(Options)
        -- Check if "Asthetic Sky" was selected
        if Options[1] == "Asthetic Sky" then
			getgenv().Lighting = game:GetService'Lighting'
			getgenv().RunService = game:GetService'RunService'
			
			local ColorCorrection = false
			local Correction = false
			local SunRays = false
			-- Change it to On and Off (true & false)
			Skybox = Instance.new("Sky", Lighting)
			Skybox.SkyboxBk = "rbxassetid://92464172"
			Skybox.SkyboxDn = "rbxassetid://92464250"
			Skybox.SkyboxFt = "rbxassetid://92464217"
			Skybox.SkyboxLf = "rbxassetid://92464234"
			Skybox.SkyboxRt = "rbxassetid://92464189"
			Skybox.SkyboxUp = "rbxassetid://92464157"
			
			RunService.Stepped:Connect(function()
			   if Lighting then
				  if Lighting:FindFirstChild"ColorCorrection" then
					 if not ColorCorrection then
						Lighting:WaitForChild"ColorCorrection":Destroy()
					 else
						return nil
					 end
				  elseif Lighting:FindFirstChild"Correction" then
					 if not Correction then
						Lighting:WaitForChild"Correction":Destroy()
					 else
						return nil
					 end
				  elseif Lighting:FindFirstChildOfClass"SunRaysEffect" then
					 if not SunRays then
						Lighting:WaitForChild"SunRaysEffect":Destroy()
					 else
						return nil
					 end
				  end
			   end
			end)
		end
    end,
})
